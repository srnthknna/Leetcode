{"id":620393473,"lang":"java","time":"1 month, 1 week","timestamp":1642268448,"status_display":"Accepted","runtime":"86 ms","url":"/submissions/detail/620393473/","is_pending":"Not Pending","title":"Contains Duplicate III","memory":"51.4 MB","code":"class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (nums.length == 0 || k <= 0) return false;\n        \n        TreeSet<Integer> set = new TreeSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            Integer one = set.ceiling(nums[i]);\n            \n            if (one != null && (long) one <= (long) nums[i] + t) return true;\n            \n            Integer two = set.floor(nums[i]);\n            \n            if (two != null && (long) two >= (long) nums[i] - t) return true;\n            \n            set.add(nums[i]);\n            if (set.size() > k)\n                set.remove(nums[i - k]);\n        }\n        return false;\n    }\n    \n    /*\n    i - j <= k\n    | nums[i] - nums[j] | <= t\n    1) [one] nums[i] - nums[j] <= t -> (ceiling) nums[i] <= nums[j] + t (floor)\n    2) [two] nums[i] - nums[j] >= -t -> (floor) nums[i] >= num[j] - t (ceil)\n    */\n}","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"contains-duplicate-iii"}