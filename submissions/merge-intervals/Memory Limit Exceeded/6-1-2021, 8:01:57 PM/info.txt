{"id":501658028,"lang":"java","time":"9Â months","timestamp":1622602917,"status_display":"Memory Limit Exceeded","runtime":"N/A","url":"/submissions/detail/501658028/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\n    private Map<int[], List<int[]>> graph;\n    private Map<Integer, List<int[]>> nodesInComp;\n    private Set<int[]> visited;\n\n    // return whether two intervals overlap (inclusive)\n    private boolean overlap(int[] a, int[] b) {\n        return a[0] <= b[1] && b[0] <= a[1];\n    }\n\n    // build a graph where an undirected edge between intervals u and v exists\n    // iff u and v overlap.\n    private void buildGraph(int[][] intervals) {\n        graph = new HashMap<>();\n        for (int[] interval : intervals) {\n            graph.put(interval, new LinkedList<>());\n        }\n\n        for (int[] interval1 : intervals) {\n            for (int[] interval2 : intervals) {\n                if (overlap(interval1, interval2)) {\n                    graph.get(interval1).add(interval2);\n                    graph.get(interval2).add(interval1);\n                }\n            }\n        }\n    }\n\n    // merges all of the nodes in this connected component into one interval.\n    private int[] mergeNodes(List<int[]> nodes) {\n        int minStart = nodes.get(0)[0];\n        for (int[] node : nodes) {\n            minStart = Math.min(minStart, node[0]);\n        }\n\n        int maxEnd = nodes.get(0)[1];\n        for (int[] node : nodes) {\n            maxEnd = Math.max(maxEnd, node[1]);\n        }\n\n        return new int[] {minStart, maxEnd};\n    }\n\n    // use depth-first search to mark all nodes in the same connected component\n    // with the same integer.\n    private void markComponentDFS(int[] start, int compNumber) {\n        Stack<int[]> stack = new Stack<>();\n        stack.add(start);\n\n        while (!stack.isEmpty()) {\n            int[] node = stack.pop();\n            if (!visited.contains(node)) {\n                visited.add(node);\n\n                if (nodesInComp.get(compNumber) == null) {\n                    nodesInComp.put(compNumber, new LinkedList<>());\n                }\n                nodesInComp.get(compNumber).add(node);\n\n                for (int[] child : graph.get(node)) {\n                    stack.add(child);\n                }\n            }\n        }\n    }\n\n    // gets the connected components of the interval overlap graph.\n    private void buildComponents(int[][] intervals) {\n        nodesInComp = new HashMap<>();\n        visited = new HashSet<>();\n        int compNumber = 0;\n\n        for (int[] interval : intervals) {\n            if (!visited.contains(interval)) {\n                markComponentDFS(interval, compNumber);\n                compNumber++;\n            }\n        }\n    }\n\n    public int[][] merge(int[][] intervals) {\n        buildGraph(intervals);\n        buildComponents(intervals);\n\n        // for each component, merge all intervals into one interval.\n        List<int[]> merged = new LinkedList<>();\n        for (int comp = 0; comp < nodesInComp.size(); comp++) {\n            merged.add(mergeNodes(nodesInComp.get(comp)));\n        }\n\n        return merged.toArray(new int[merged.size()][]);\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110","title_slug":"merge-intervals"}