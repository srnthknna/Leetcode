{"id":649436605,"lang":"java","time":"1 day, 3 hours","timestamp":1645910972,"status_display":"Accepted","runtime":"79 ms","url":"/submissions/detail/649436605/","is_pending":"Not Pending","title":"Minimum Height Trees","memory":"90 MB","code":"// https://www.youtube.com/watch?v=1ZDg3jk7dUE&list=PLEI-q7w3s9gRa-dGulP1CZfN-2w_uiGAK&index=12&ab_channel=CodingDecoded\n// Solution is as follows\n// Find the indegree for all the nodes and build the adj list\n// populate the queue with all the nodes which as the indegree with 1\n// it means that when the indegree is 1 its a leaf\n// Then its going to be a proper bfs where we find all the neighbhors for the leaf\n// reduce the indegree of the neigh considering we are deleting the link to it from the leaf\n// once the leaf is deleted if the current indegree of the node becomes 1 then its the potential candidate for the next iteration in the bfs so we add that node to the leaf\nclass Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        List<Integer> result = new ArrayList<>();\n        if (n <= 0) return result;\n        if (n == 1) {\n            result.add(0);\n            return result;\n        }\n        \n        int[] indegree = new int[n];\n        Map<Integer, Set<Integer>> adjList = new HashMap<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int[] edge : edges) {\n            indegree[edge[0]]++;\n            indegree[edge[1]]++;\n            adjList.putIfAbsent(edge[0], new HashSet<>());\n            adjList.putIfAbsent(edge[1], new HashSet<>());\n            adjList.get(edge[0]).add(edge[1]);\n            adjList.get(edge[1]).add(edge[0]);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (indegree[i] == 1) {\n                queue.offer(i);\n            }\n        }\n        \n        while (n > 2) {\n            int size = queue.size();\n            n -= size;\n            for (int i = 0; i < size; i++) {\n                int curr = queue.poll();\n                for (int neigh : adjList.get(curr)) {\n                    indegree[neigh]--;\n                    adjList.get(neigh).remove(curr);\n                    if (indegree[neigh] == 1) {\n                        queue.offer(neigh);\n                    }\n                }\n            }\n        } \n        return new ArrayList<>(queue);\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-height-trees"}