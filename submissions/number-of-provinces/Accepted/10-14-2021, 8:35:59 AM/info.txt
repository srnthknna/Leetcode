{"id":571166149,"lang":"java","time":"4 months, 2 weeks","timestamp":1634225759,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/571166149/","is_pending":"Not Pending","title":"Number of Provinces","memory":"51.8 MB","code":"class Solution1 {\n    // Quick union is needed to assign the same parent root value to all the nodes in a set\n    class UnionFind {\n        int root[];\n        \n        public UnionFind(int n) {\n            root = new int[n];\n            for (int i = 0; i < n; i++) {\n                root[i] = i;\n            }\n        }\n        \n        public boolean isConnected(int x, int y) {\n            return find(x) == find(y);\n        }\n        \n        public int find(int x) {\n            return root[x];\n        }\n        \n        public void union(int x, int y) {\n            int findx = find(x);\n            int findy = find(y);\n            if (findx != findy) {\n                for (int i = 0; i < root.length; i++)\n                    if (root[i] == findy)\n                        root[i] = findx;\n            }\n        }\n    }\n    \n    public int findCircleNum(int[][] isConnected) {\n        UnionFind sets = new UnionFind(isConnected.length);\n        for (int i = 0; i < isConnected.length; i++) {\n            for (int j = 0; j < isConnected[0].length; j++) {\n                if (isConnected[i][j] == 1 && i != j) {\n                    sets.union(i, j);\n                }\n            }\n        }\n        \n        Set<Integer> answer = new HashSet();\n        for (int i : sets.root)\n            answer.add(i);\n        return answer.size();\n    }\n}\nclass Solution {\n    // Union find with path compression\n    class UnionFind {\n        int root[];\n        int rank[];\n        int count = 0;\n        \n        public UnionFind(int n) {\n            root = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                root[i] = i;\n                rank[i] = 1;\n            }\n            count = n;\n        }\n        \n        public boolean isConnected(int x, int y) {\n            return find(x) == find(y);\n        }\n        \n        public int find(int x) {\n            if (x == root[x])\n                return x;\n            return root[x] = find(root[x]);\n        }\n        \n        public void union(int x, int y) {\n            int findx = find(x);\n            int findy = find(y);\n            if (findx != findy) {\n                if (rank[findx] > rank[findy]) {\n                    root[findy] = findx;\n                } else if (rank[findx] < rank[findy]) {\n                    root[findx] = findy;\n                } else {\n                    root[findy] = findx;\n                    rank[findx] += 1;\n                }\n                count--;\n            }\n        }\n    }\n    \n    public int findCircleNum(int[][] isConnected) {\n        UnionFind sets = new UnionFind(isConnected.length);\n        for (int i = 0; i < isConnected.length; i++) {\n            for (int j = 0; j < isConnected[0].length; j++) {\n                if (isConnected[i][j] == 1 && i != j) {\n                    sets.union(i, j);\n                }\n            }\n        }\n        \n        return sets.count;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-provinces"}