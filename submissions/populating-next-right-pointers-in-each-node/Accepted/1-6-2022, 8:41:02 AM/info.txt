{"id":614342642,"lang":"java","time":"1 month, 3 weeks","timestamp":1641487262,"status_display":"Accepted","runtime":"9 ms","url":"/submissions/detail/614342642/","is_pending":"Not Pending","title":"Populating Next Right Pointers in Each Node","memory":"44.6 MB","code":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null)\n            return root;\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                Node curr = queue.poll();\n                \n                if (i < size - 1) {\n                    curr.next = queue.peek();\n                }\n                \n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n                \n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        return root;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"populating-next-right-pointers-in-each-node"}