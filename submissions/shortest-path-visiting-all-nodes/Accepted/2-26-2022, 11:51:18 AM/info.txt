{"id":649392934,"lang":"java","time":"1 day, 4 hours","timestamp":1645905078,"status_display":"Accepted","runtime":"14 ms","url":"/submissions/detail/649392934/","is_pending":"Not Pending","title":"Shortest Path Visiting All Nodes","memory":"48.7 MB","code":"// https://github.com/Sunchit/Coding-Decoded/blob/master/February2022/Java/ShortestPathVisitingAllNodes.java\n// https://www.youtube.com/watch?v=1XkMFNvkouo&ab_channel=CodingDecoded\n// Key to note here is each node has its own states length to reach the all paths\n// to avoid cycles we use the 2^n paths per node to track visited\n// eg 1-0-1-0 its useless so to track the possible next paths we only consider which is currently not considered in the current node iteration\nclass Solution {\n    public int shortestPathLength(int[][] graph) {\n        if (graph.length == 1) return 0;\n        int shortest = 0, n = graph.length;\n        \n        int finalState = (1 << n) - 1;\n        \n        int[][] visited = new int[n][finalState + 1];\n        Queue<int[]> queue = new LinkedList<>();\n        \n        for (int i = 0; i < n ; i++) {\n            queue.offer(new int[] {i, 1 << i});\n        }\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            shortest++;\n            for (int i = 0; i < size; i++) {\n                int[] curr = queue.poll();\n                int currNode = curr[0], currState = curr[1];\n                \n                for (int neigh : graph[currNode]) {\n                    int nextState = currState | (1 << neigh);\n                    if (visited[neigh][nextState] == 1) continue;\n                    visited[neigh][nextState] = 1;\n                    if (nextState == finalState) return shortest;\n                    queue.offer(new int[] {neigh, nextState});\n                }\n            }\n        }\n        return -1;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-visiting-all-nodes"}