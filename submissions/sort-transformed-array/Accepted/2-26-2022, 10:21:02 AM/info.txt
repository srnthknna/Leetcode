{"id":649348278,"lang":"java","time":"1 day, 6 hours","timestamp":1645899662,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/649348278/","is_pending":"Not Pending","title":"Sort Transformed Array","memory":"43 MB","code":"// Yes the generic way is to update the array with new values and sorting it\n// its O(n) to find new values and O(nlogn) to sort them lets try that first\nclass Solution1 {\n    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = nums[i] * nums[i] * a + b * nums[i] + c;\n        }\n        Arrays.sort(nums);\n        return nums;\n    }\n}\n\n// Next will be to use TreeSet to store the values in the sorted order\n// TreeSet will not work if there are duplicates;\nclass Solution2 {\n    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n        TreeSet<Integer> vals = new TreeSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            System.out.println(nums[i] * nums[i] * a + b * nums[i] + c);\n            vals.add(nums[i] * nums[i] * a + b * nums[i] + c);\n        }\n        int i = 0;\n        int[] result = new int[nums.length];\n        for (int val : vals) {\n            result[i++] = val;\n        }\n        return result;\n    }\n}\n\n// Two pointer\n// If multiplicity of n2 greater than 0 then fill from back\n// back fill considers lower value first\n// else fill from front\n// front fill considers greater value first\nclass Solution {\n    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n        int n = nums.length, i = a > 0 ? n - 1 : 0;\n        int[] result = new int[nums.length];\n\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            int leftVal = (nums[left] * nums[left] * a + b * nums[left] + c);\n            int rightVal = (nums[right] * nums[right] * a + b * nums[right] + c);\n                \n            if (a <= 0) {\n                if (leftVal < rightVal) {\n                    result[i++] = leftVal;\n                    left++;\n                } else {\n                    result[i++] = rightVal;\n                    right--;\n                }\n            } else {\n                if (leftVal < rightVal) {\n                    result[i--] = rightVal;\n                    right--;\n                } else {\n                    result[i--] = leftVal;\n                    left++;\n                } \n            }\n        }\n        \n        return result;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"sort-transformed-array"}